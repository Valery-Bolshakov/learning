class Person:
    # зададим свойство - имя со значением по умолчанию
    # перенесем это свойство в конструктор
    # name = 'John'

    # КОНСТРУКТОР КЛАССА:
    # Через конструктор можно определить ключевые атрибуты класса
    # Теперь когда создается экземпляр - вызывается метод инит. И в свойство name - записывается значение name
    def __init__(self, name):
        self.name = name
        # создадим одинаковое свойство доля всех обьектов
        self.__age = 20  # Приватный(неизменяемый) атрибут
        # self._age = 20  # Условно защищенный атрибут. Т.е.  программист задумал его как неизменяемый

    # создаем метод который будет печатать данные о какой то персоне
    def print_info(self):
        print(f'Name:  {self.name}, Age: {self.__age}')

    # Запишем методы геттер и сеттер для закрытого свойства:
    # геттер - получить данные
    def get_age(self):
        return self.__age

    # сеттер - поменять данные
    # помимо self данный метод принимает еще один параметр, который мы будем задавать при вызове метода.
    # Значение защищенного параметра изменится на заданный в методе сеттер параметр
    def set_age(self, elem):
        # self.__age = elem
        # с помощью данного метода можно проконтролировать корректность задаваемого значения. Например что бы его
        # не изменили на строчное или на неприемлемый возраст:
        if elem in range(1, 101):
            self.__age = elem
        else:
            print('Wrong age')

    # Так же есть функции декораторы для изменения приватных параметров
    # Сеттер и Геттер должны наываться ОДИНАКОВО
    # Геттер - что бы данный метод стал полноценным геттером - пишем следующее: ( декоратор - @property)
    @property
    def age(self):
        return self.__age  # это своеобразный геттер

    # Сеттер - @age.setter:
    @age.setter
    def age(self, elem):
        if elem in range(1, 101):
            self.__age = elem
        else:
            print('Wrong age')
