print('Работа с файлами\n')

'''
    OPEN - Открывает файл и возвращает представляющий его объект.
open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None) -> file

    Режимы открытия файла
r	для чтения (3.0 синоним rt).
w	для записи (если не существует - будет создан, если файл существует, то будет очищен).
a	для добавления (на некоторых Unix-системах любая попытка записи пишет в конец файла вне зависимости от позиционирования — seek()).
b	постфикс двоичного режима (для операционных систем, которые различают текстовые и двоичные файлы).
+	постфикс обновления (чтение + запись).
U	постфикс универсальных переводов строк (4.0 устарел, используйте параметр newline).
t	3.0 постфикс текстового режима.
x	3.3 эксклюзивное создание (возбуждается исключение FileExistsError, если файл уже существует).

    Использование оператора "with" позволяет не вызывать явным образом метод close() (АВТОМАТИЧЕСКИ ЗАКРЫВАЕТ).
with open('myfile.txt', 'r+') as f:  # Открываем на чтение и запись.
    f.write('0123456789')  # Пишем данные в файл.
    
'''
f = open('file.txt', 'r', encoding='utf-8')

'''
FILE.READ - Считывает и возвращает указанное количество данных из файла.
file.read(size)
size : Число — максимальное количество данных, которое требуется считать. Если параметр не задан, 
либо число отрицательное, содержимое файла будет считано полностью.
'''
text = f.read()  # Метод прочитает ВЕСЬ файл
'''Если файл уже был прочитан Весь, то дальнейший вызов метода чтения ничего не даст. т.к. файл Уже прочитан'''

# text2 = f.read(8)  # Метод прочитает Первые 8 символов
print(f.encoding)  # Файл открылся с кодировкой 'cp1251', и на выходе получится херня. по этому задаем кодировку

f.close()

# print(text)  # Строка 1 Строка 2 Строка 3
# print(text2)  # Строка 1

'''
    FILE.WRITE - Записывает в файл указанную строку.
    
file.write(str) -> None | int
str : Строка, которую требуется запись в файл.
Возвращает количество записанных байтов (ранее возвращал None).

with open('my_file.txt', 'w') as f:
    f.write('some')  # 4
'''

f = open('file.txt', 'a', encoding='utf-8')

# Добавляем новую строку:
# f.write('New string\n')  # Добавляем перенос строки

# Добавляем Список строк: для этого надо пройтись циклом по списку
lines = ['New string_1', 'New string_2']
# for i in lines:
#     f.write(i + '\n')

'''
    FILE.WRITELINES - Записывает в файл указанную последовательность строк.
    
file.writelines(lines) -> None
lines : Последовательность, которой может являться любой объект, поддерживающий итерирование и производящий строки.

    with open('my_file.txt', 'w') as f:
        f.writelines(['one', 'two'])
        # В файле my_file.txt получим 
        # onetwo
'''

# f.writelines(lines)  # New string_1New string_2 - Пробелы надо ставить вручную!

# f.writelines(f'{i}\n' for i in lines)

f.close()
print(text)

'''Построковое чтение файла
Считывает из файла одну строку и возвращает её.
file.readline() -> str
'''
f = open('file.txt', 'r', encoding='utf-8')
# Можно обойтись простым циклом
for line in f:
    # Избавляемся от лишних переносов строки 2мя методами:
    print(line, end='')
    # print(line.replace('\n', ''))

f.close()

'''
Создадим новый файл:
создается новый файл и в него записываются указанные строки New string_1 New string_2
'''

f = open('file_1.txt', 'w', encoding='utf-8')

f.writelines(f'{i}\n' for i in lines)

f.close()
